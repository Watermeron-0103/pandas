# 品目コードの正規化スクリプト備忘録

この備忘録では、Excel/CSV ファイルに含まれる「品目コード」列に対して余分な空白の削除や末尾の Rev 情報の削除を行う Python スクリプトの使い方と、そのポイントを解説します。  

## 目的

* **空白の削除**: 半角・全角スペース、タブや改行などの空白をすべて除去します。  
* **Rev の削除**: 品目コード末尾が数字であり、その直前が英字またはアンダースコア (`_`) の場合に、その末尾 1 桁だけを削除します。  
* **列名の自動検出**: 「品目コード」「品目」「部品番号」「部品コード」「品番」「コード」「item_code」「part_code」「品目CD」などの列名から、自動的に対象列を検出します。
* **マルチシート対応**: Excel ファイルのすべてのシートを処理し、元列と正規化列を併記したバージョン、元列を置換したバージョン、差分レポートの 3 種類を出力します。

## スクリプトのポイント

- 空白除去には正規表現 `[\s\u3000]+` を使い、半角・全角スペースやタブ、改行を一括で削除します。
- Rev 削除では、旧正規表現 `([A-Za-z_])\d+$` を使用するとアルファベット直後の連続する数字すべてが削除されてしまうため、  
  `10A10322812` のようなコードも末尾が「10A」になってしまう問題がありました。  
  この問題を防ぐため、本スクリプトでは `([A-Za-z_])\d$` を採用し、**末尾 1 桁のみ**を対象にします。  
  これにより、「直前が英字または `_` で、末尾が 1 桁の数字」というパターンだけ Rev とみなし削除します。
- 列名検出では完全一致の「品目コード」を優先し、その後「品目」や「部品コード」などの部分一致で対象列を選択します。

## 使用方法

1. Python スクリプト内の `in_path` 変数に、対象となる Excel/CSV ファイルの絶対パスを指定します。  
2. スクリプトを実行すると、入力ファイルと同じフォルダに次のファイルが生成されます:  
   - `*_cleaned_addedcol.xlsx`: 元の列に `<列名>_cleaned` を追加したファイル  
   - `*_cleaned.xlsx`: 品目コード列を正規化値で上書きしたファイル  
   - `*_diff_changed_only.xlsx`: 変更があった行だけを抽出した差分レポート  
3. 生成されたファイルを確認し、正しく変換されているかをチェックしてください。

## 動作例

|元の値|変換後|備考|
|---|---|---|
|`10A 10322812`|`10A10322812`|空白のみ削除し、末尾の数字は削除しない|
|`108B 1251098A1`|`108B1251098A`|末尾の `1` は Rev とみなし削除|
|`13B 1295631_1`|`13B1295631_`|末尾の `1` を削除し `_` で終わる|
|`ABC123`|`ABC123`|直前が数字のため Rev 削除しない|
|`X_9`|`X_`|`_` の右隣に 1 桁の数字があるため削除|

## 完全な Python スクリプト

以下が修正版の完全な Python スクリプトです。`in_path` で指定したファイルを読み込み、品目コードを正規化した結果をそれぞれ出力します。  

```python
#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import pandas as pd
import re
from pathlib import Path
import numpy as np

# ====== ここを指定してください ======
in_path = Path(r"c:\\Users\\11064667.FFWIN\\Documents\\Mike-Tython\\pandapandapanda\\Hitman\\関さん依頼_BE品整合性チェック\\out\\調査(2024)_品目コード_サプライヤ一覧.xlsx")
# ===================================

_space_pat = re.compile(r'[\s\u3000]+')
_rev_trim_pat = re.compile(r'([A-Za-z_])\d$')

def normalize_item_code(val):
    """品目コードの空白削除と Rev 削除を行います。"""
    if pd.isna(val):
        return val
    s = str(val)
    s = _space_pat.sub('', s)
    s = _rev_trim_pat.sub(r'\1', s)
    return s

preferred_exact = ["品目コード"]
preferred_contains = ["品目コード", "品目", "部品番号", "部品コード", "品番", "コード",
                      "item_code", "part_code", "品目CD"]
fallback_contains = ["code", "CODE", "Code"]

def find_code_column(df: pd.DataFrame):
    """品目コード列を推測して返します。"""
    cols = list(df.columns)
    # 完全一致
    for name in preferred_exact:
        if name in cols:
            return name
    # 部分一致
    for name in cols:
        for key in preferred_contains:
            if key in str(name):
                return name
    # フォールバック
    for name in cols:
        for key in fallback_contains:
            if key in str(name):
                return name
    return None

def main():
    # Excel 全シートを読み込み
    sheets = pd.read_excel(in_path, sheet_name=None)
    processed_sheets_addedcol = {}
    processed_sheets_replaced = {}
    diff_summaries = {}

    for sheet_name, df in sheets.items():
        df_work = df.copy()
        code_col = find_code_column(df_work)
        if code_col is None:
            processed_sheets_addedcol[sheet_name] = df_work
            processed_sheets_replaced[sheet_name] = df_work
            diff_summaries[sheet_name] = pd.DataFrame(columns=["before", "after"])
            continue

        cleaned = df_work[code_col].apply(normalize_item_code)

        before = df_work[code_col].astype(str).fillna("")

        after = cleaned.astype(str).fillna("")

        changed_mask = before != after
        diff_df = pd.DataFrame({"before": df_work[code_col], "after": cleaned})
        diff_df = diff_df[changed_mask]

        # 元列＋ _cleaned 列
        df_added = df_work.copy()
        new_col_name = f"{code_col}_cleaned"
        df_added[new_col_name] = cleaned
        processed_sheets_addedcol[sheet_name] = df_added

        # 元列を置換
        df_replaced = df_work.copy()
        df_replaced[code_col] = cleaned
        processed_sheets_replaced[sheet_name] = df_replaced

        diff_summaries[sheet_name] = diff_df

    # 保存パス生成
    base = in_path.with_suffix("")

    out_with_added = Path(str(base) + "_cleaned_addedcol.xlsx")
    out_replaced = Path(str(base) + "_cleaned.xlsx")
    out_diff = Path(str(base) + "_diff_changed_only.xlsx")

    # 出力
    with pd.ExcelWriter(out_with_added, engine="openpyxl") as writer:
        for s, df in processed_sheets_addedcol.items():
            df.to_excel(writer, sheet_name=s[:31], index=False)

    with pd.ExcelWriter(out_replaced, engine="openpyxl") as writer:
        for s, df in processed_sheets_replaced.items():
            df.to_excel(writer, sheet_name=s[:31], index=False)

    with pd.ExcelWriter(out_diff, engine="openpyxl") as writer:
        for s, df in diff_summaries.items():
            if df.empty:
                tmp = pd.DataFrame({"before": [np.nan], "after": [np.nan]})
                tmp.to_excel(writer, sheet_name=s[:31], index=False)
            else:
                df.to_excel(writer, sheet_name=s[:31], index=False)

    print("出力完了")
    print("追加列バージョン:", out_with_added)
    print("置換バージョン:", out_replaced)
    print("差分レポート:", out_diff)

if __name__ == '__main__':
    main()
```

スクリプトを実行する前に、Python 環境に `pandas`、`openpyxl` 等のライブラリがインストールされていることを確認してください。  

## おわりに

このスクリプトと備忘録は、品目コードのクレンジング作業を効率化するためのものです。要件に応じて正規表現や列名リストを拡張し、現場のデータ形式に合わせて調整してください。
