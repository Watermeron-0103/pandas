# 追加で覚えておくべき pandas のポイント

このセクションでは、納入日分析の備忘録に加えて覚えておくと便利な **pandas** の使い方や注意点をまとめます。日々のデータ分析やスクリプト作成の際に役立つテクニックを記録しておきましょう。

## グループ化 (`groupby`) の注意点

- **サイズと件数の違い**: `DataFrame.groupby().size()` は各グループの行数（NaN も含む）をカウントするのに対し、`DataFrame.groupby().count()` は各列の非欠損値のみをカウントします。グループ内の欠損を含めたいときは `.size()`、欠損を除外したいときは `.count()` を使います。
- **先頭・末尾・特定行の取得**: `first()` と `last()` は各グループの最初・最後の非欠損行を返します。一方、`nth(n)` は欠損を含めて *n* 番目の行を返すため、例えば `nth(0)` で本当に 1 行目を取得できます。欠損を無視せず順位で取り出したいときは `nth()` が有効です。
- **グループごとのデータ取得**: `get_group(name)` で特定グループの内容をそのまま取得できます。フィルタ条件を書かなくても `df.groupby(“列名”).get_group('キー値')` で直接取り出せるので高速です。

## インデクシングと抽出 (`loc` と `iloc`)

- `loc[]` は **ラベル（インデックス名や列名）** で行や列を選択し、`iloc[]` は **数値位置** で選択します。`loc` で存在しないラベルを指定すると `KeyError`、`iloc` で範囲外の位置を指定すると `IndexError` になります。
- `loc` で範囲を指定すると終端を **含む** のに対し、`iloc` では Python のスライスと同様に終端を **含まない** ことに注意します。
- `loc` はブール配列による条件抽出もサポートします。一方、`iloc` では数値位置しか使えません。

## データ結合 (`merge` と `join` の違い)

- `join()` は **インデックスに対する結合** に使われ、デフォルトでは **左結合** を行います【409609516634108†L100-L110】。列同士で結合したい場合は当該列をインデックスに設定する必要があります。
- `merge()` は **列またはインデックス** で柔軟に結合でき、デフォルトでは **内部結合** を行います【409609516634108†L100-L118】。`on`、`left_on`、`right_on` で結合キーを指定したり、`how` で `inner`/`left`/`right`/`outer`/`cross` を選べます。
- `join()` は DataFrame メソッドであり、`merge()` は `pandas.merge()` というトップレベル関数です。クロス結合（全組合わせ）は `merge()` のみがサポートします。

## Excel への出力 (`to_excel`)

- 単一シートへの書き出しは `df.to_excel('file.xlsx')` だけで済みますが、**複数シート** に書き出す場合は `pd.ExcelWriter` を使います【552240738081499†L133-L141】。例えば、同じブックに 2 つの DataFrame を保存する場合:

  ```python
  with pd.ExcelWriter('output.xlsx') as writer:
      df1.to_excel(writer, sheet_name='Sheet1')
      df2.to_excel(writer, sheet_name='Sheet2')
  ```

- 既存のファイル名で `ExcelWriter` を作成すると、そのファイルは **上書き** されます。既存のブックに追加する場合は `mode='a'` を指定します。
- ブックを保存した後は追加書き込みができないため、すべてのシートを書き終えたら最後に `save()` されることを忘れずに。

## ループよりベクトル化

- Pandas では行ごとに処理を行うループよりも **ベクトル化されたメソッド**（列全体に対して一括で処理する方法）を優先します。行方向の繰り返しは簡単ですが、多くの場合 **パフォーマンスが大幅に低下** します【647528333410684†L91-L95】。
- どうしてもループを使う場合は `.itertuples()` が `.iterrows()` より高速です。しかし、データセットが大きい場合や数値計算の場合は `df['列'] * 2` のようなベクトル漾算や `np.where()`、`df.apply()` などの関数を検討してください。

## `SettingWithCopyWarning` の理解

- Pandas は、データの一部を選択した後に値を書き換える際に **`SettingWithCopyWarning`** を表示することがあります。これはビュー（淺いコピー）とコピー（深いコピー）の違いに起因し、不適切な操作によって元のデータが意図せず変更される可能性を警告しています【541647152419549†L98-L103】。
- この警告を避けるには、チェーンインデックス（`df[df['A']>0]['B'] = 1` のような記述）を使わず、`loc` を使って明示的に代入するか、抽出したデータを `.copy()` でコピーしてから編集します。

これらのポイントを備忘録に追加すると、今後のデータ分析で pandas をより効率的に利用できるはずです。必要に応じて、これらの項目を越社の GitHub リポジトリ内の備忘録ファイルに追加してください。
